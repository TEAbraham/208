<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Mr.&nbsp;Abraham">

<title>Unit 8 Review</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="8.Review_files/libs/clipboard/clipboard.min.js"></script>
<script src="8.Review_files/libs/quarto-html/quarto.js"></script>
<script src="8.Review_files/libs/quarto-html/popper.min.js"></script>
<script src="8.Review_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="8.Review_files/libs/quarto-html/anchor.min.js"></script>
<link href="8.Review_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="8.Review_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="8.Review_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="8.Review_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="8.Review_files/libs/bootstrap/bootstrap-c0367b04c37547644fece4185067e4a7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Unit 8 Review</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Mr.&nbsp;Abraham </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="unit-8-review" class="level3">
<h3 class="anchored" data-anchor-id="unit-8-review">Unit 8 Review</h3>
<section id="section-8a-chi-square-tests-for-goodness-of-fit" class="level4">
<h4 class="anchored" data-anchor-id="section-8a-chi-square-tests-for-goodness-of-fit">Section 8A: Chi-Square Tests for Goodness of Fit</h4>
<p>In this section, you learned how to perform a <strong>chi-square test for goodness of fit</strong>. The null hypothesis is that a single categorical variable follows a specified distribution in a population of interest. The alternative hypothesis is that the variable does not follow the specified distribution in the population of interest.</p>
<p>The <strong>chi-square test statistic <span class="math inline">\(\chi^2\)</span></strong> measures the difference between the observed distribution of a categorical variable and its hypothesized distribution. To calculate the chi-square test statistic, use the following formula with observed and expected counts: <span class="math display">\[\chi^2=\sum{\frac{(\text{Observed - Expected})^2}{\text{Expected}}}\]</span> To calculate the expected counts, multiply the sample size by the proportion specified by the null hypothesis for each category. Larger values of the chi-square test statistic provide more convincing evidence that the distribution of the categorical variable differs from the hypothesized distribution in the population of interest.</p>
<p>To ensure that the observations in the sample can be viewed as independent and that the sampling distribution of the chi-square test statistic can be modeled by a chi-square distribution, we check three conditions. The Random condition says that the data are from a random sample from the population of interest. The <span class="math inline">\(10\%\)</span> condition says that the sample size should be less than <span class="math inline">\(10\%\)</span> of the population size when sampling without replacement. The Large Counts condition says that the <em>expected</em> counts for each category must be at least five. In a test for goodness to fit, use a chi-square distribution with degrees of freedom = number of categories <span class="math inline">\(- 1\)</span>.</p>
<p>When the results of a test for goodness to fit are significant, consider doing a <em>follow up analysis</em>. Identify which categories of the variable made the largest contributions to the chi-square test statistic and whether the observed values in those categories were larger or smaller than expected.</p>
<p>A sky square test for goodness of it uses the same logic as the previously introduced significant tests. Likewise, the way we interpret <span class="math inline">\(P\)</span>-values and power and the way we describe Type I and Type II errors is very similar to what you learned earlier.</p>
</section>
<section id="section-8b-chi-square-tests-for-independence-or-homogeneity" class="level4">
<h4 class="anchored" data-anchor-id="section-8b-chi-square-tests-for-independence-or-homogeneity">Section 8B: Chi-Square Tests for Independence or Homogeneity</h4>
<p>In this section, you learn two different tests to analyze categorical data that are summarized in a two-way table. A <strong>chi-square test for independence</strong> looks for an association between two categorical variables in a single population. A <strong>chi-square test for homogeneity</strong> compares the distribution of a single categorical variable for two or more populations or treatments.</p>
<p>In a chi-square test for independence, the null hypothesis is that there is no association between two categorical variables in one population (or that the two variables are independent in the population). The alternative hypothesis is that there is an association between the two variables (or that the two variables are not independent).</p>
<p>As with other significance tests, we need to verify that the observations in the sample can be viewed as independent and that the sampling distribution of the chi-square test statistic can be modeled by a chi-square distribution. The conditions for a chi-square test for independence are exactly the same as the conditions for a chi-square test for goodness of fit. However, there is a new method for calculating the expected counts: <span class="math display">\[\text{expected count} = \frac{\text{(row total)}\text{(column total)}}{\text{table total}}\]</span> To calculate the P value, compute the chi-square test statistic and use a high square distribution with degrees of freedom = (number of rows - 1)(number of columns - 1).</p>
<p>In a chi-square test for homogeneity, the null hypothesis is that there is no difference in the distribution of a categorical variable for two or more populations or treatments.the alternative hypothesis is that there is a difference in the distributions.</p>
<p>The conditions are slightly different, but the purpose for checking them is still the same: to ensure independence in the data collection process and verify that the sampling distribution of the chi-square test statistic can be modeled by a chi-square distribution. The Random Condition is that the data come from independent random samples from groups in a randomized experiment. The <span class="math inline">\(10\%\)</span> condition applies for each sample when sampling without replacement, but not for experiments when there is no sampling without replacement from a population. Finally the large counts condition remains the same – the expected counts must be at least five in each cell of the two-way table. The methods for calculating expected counts, the chi-square test statistic, the degrees of freedom, and the <span class="math inline">\(P\)</span>-value are exactly the same in a test for homogeneity as in the test for independence.</p>
<p>As with tests for goodness to fit, when the results of a test for homogeneity or a test for independence are significant, consider doing a follow up analysis. Identify which cells in the two-way table made the largest contributions to the chi-square test statistic and whether the observed counts in those cells were larger or smaller than expected.</p>
<p>The chi-square tests for independence and homogeneity use the same logic at the previously discussed significance tests. Likewise, the way we interpret <span class="math inline">\(P\)</span>-values and power and the way we describe Type I and Type II errors is very similar to what you learned in previous units.</p>
</section>
</section>
<section id="comparing-the-three-chi-square-tests" class="level3">
<h3 class="anchored" data-anchor-id="comparing-the-three-chi-square-tests">Comparing the Three Chi-Square Tests</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 26%">
<col style="width: 26%">
<col style="width: 26%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Number of samples/treatments</strong></td>
<td style="text-align: left;"><span class="math inline">\(1\)</span></td>
<td style="text-align: left;"><span class="math inline">\(1\)</span></td>
<td style="text-align: left;"><span class="math inline">\(2\)</span> or more</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Null Hypothesis</strong></td>
<td style="text-align: left;">The stated distribution of a categorical variable in the population of interest is correct.</td>
<td style="text-align: left;">There is no association between two categorical variables in the population of interest.</td>
<td style="text-align: left;">There is no difference in the distribution of a categorical variable for several populations or treatments.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Random condition</strong></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">The data come from a random sample from the population of interest.</td>
<td style="text-align: left;">The data come from independent random samples or groups in a randomized experiment.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong><span class="math inline">\(10\%\)</span> condition</strong></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">When sampling without replacement, <span class="math inline">\(n &lt; 0.10N\)</span> for each sample.</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Large Counts condition</strong></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">All expected counts <span class="math inline">\(\ge 5\)</span>.</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Expected Counts</strong></td>
<td style="text-align: left;"><span class="math inline">\(np_i\)</span><br><br>where <span class="math inline">\(p_i\)</span> is the proportion specified by the null hypothesis for a particular category</td>
<td style="text-align: left;"><span class="math display">\[\frac{\text{(row total)}\text{(column total)}}{\text{table total}}\]</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Formula for test statistic</strong></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math display">\[\chi^2=\sum{\frac{(\text{Observed - Expected})^2}{\text{Expected}}}\]</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Degrees of freedom</strong></td>
<td style="text-align: left;"># categories - 1</td>
<td style="text-align: left;">(# rows - 1)(# columns - 1)</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Name (TI-83/84)</strong></td>
<td style="text-align: left;"><span class="math inline">\(\chi^2\)</span>GOF-test</td>
<td style="text-align: left;"><span class="math inline">\(\chi^2\)</span>-test</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<br><footer>Thomas Abraham © 2025</footer></body></html>