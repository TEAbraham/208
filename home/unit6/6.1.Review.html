<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Mr.&nbsp;Abraham">

<title>Unit 6, Part I Review</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="6.1.Review_files/libs/clipboard/clipboard.min.js"></script>
<script src="6.1.Review_files/libs/quarto-html/quarto.js"></script>
<script src="6.1.Review_files/libs/quarto-html/popper.min.js"></script>
<script src="6.1.Review_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="6.1.Review_files/libs/quarto-html/anchor.min.js"></script>
<link href="6.1.Review_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="6.1.Review_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="6.1.Review_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="6.1.Review_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="6.1.Review_files/libs/bootstrap/bootstrap-c0367b04c37547644fece4185067e4a7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Unit 6, Part I Review</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Mr.&nbsp;Abraham </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="unit-6-part-i-review" class="level3">
<h3 class="anchored" data-anchor-id="unit-6-part-i-review">Unit 6, Part I Review</h3>
<section id="section-6a-confidence-intervals-the-basics" class="level4">
<h4 class="anchored" data-anchor-id="section-6a-confidence-intervals-the-basics">Section 6A: Confidence Intervals: The Basics</h4>
<p>In this section, you learned that a <strong>point estimate</strong> is the single best guess for the value of a population parameter. You also learned that a <strong>confidence interval</strong>, also known as an <strong>interval estimate</strong>, provides an interval of plausible values for a parameter based on sample data. To interpret a confidence interval, say, “We are <span class="math inline">\(C\%\)</span> confident that the interval from ______ to _______ captures the [parameter in context],” where <span class="math inline">\(C\)</span> is the confidence level of the interval. You can use a confidence interval to evaluate a claim about the value of a population parameter.</p>
<p>The <strong>confidence level</strong> <span class="math inline">\(C\)</span> describes the percentage of confidence intervals that we expect to capture the value of the parameter in repeated sampling. To interpret a <span class="math inline">\(C\%\)</span> confidence level, say, “If we took many samples of the same size from the same population and used them to construct <span class="math inline">\(C\%\)</span> confidence intervals, about <span class="math inline">\(C\%\)</span> of those intervals would capture the [parameter in context].”</p>
</section>
<section id="section-6b-confidence-intervals-for-a-population-proportion" class="level4">
<h4 class="anchored" data-anchor-id="section-6b-confidence-intervals-for-a-population-proportion">Section 6B: Confidence Intervals for a Population Proportion</h4>
<p>In this section, you learned how to construct and interpret confidence intervals for a population proportion. Three conditions must be met to ensure that the observations in the sample are independent and that the sampling distribution of <span class="math inline">\(\hat{p}\)</span> is approximately normal. First, the data used to calculate the interval must come from a random sample from the population of interest (the Random condition). When the sample is selected without replacement from the population, the sample size should be less than <span class="math inline">\(10\%\)</span> of the population size (the <span class="math inline">\(10\%\)</span> condition). Finally, the observed number of successes <span class="math inline">\(n\hat{p}\)</span> and observed number of failures <span class="math inline">\(n(1-\hat{p})\)</span> must both be at least 10 (the Large Counts condition).</p>
<p>Confidence intervals are formed by adding and subtracting the <strong>margin of error</strong> from the point estimate (value of the statistic): <span class="math display">\[\text{CI} = \text{point estimate} \pm \text{margin of error}\]</span> The margin of error has two components: (<span class="math inline">\(1\)</span>) the <strong>standard error</strong> of the statistic, which is an estimate of the standard deviation of the sampling distribution of the statistic, and (<span class="math inline">\(2\)</span>) the <strong>critical value</strong> based on the confidence level of the interval. <span class="math display">\[\text{CI} = \text{statistic} \pm \text{(critical value)(standard error of statistic)}\]</span> The specific formula for calculating a confidence interval for a population proportion is <span class="math display">\[\hat{p}\pm z^\ast\sqrt{\frac{\hat{p}(1-\hat{p})}{n}}\]</span> where <span class="math inline">\(\hat{p}\)</span> is the sample proportion, <span class="math inline">\(z^\ast\)</span> is the critical value, and <span class="math inline">\(n\)</span> is the sample size. To find <span class="math inline">\(z^\ast\)</span> use technology or Table A to determin the values of <span class="math inline">\(z^\ast\)</span> and <span class="math inline">\(-z^\ast\)</span> that capture the middle <span class="math inline">\(C\%\)</span> of the standard normal distribution, where <span class="math inline">\(C\)</span> is the confidence level.</p>
<p>The <strong>four-step process</strong> (State, Plan, Do, Conclude) is perfectly suited for problems that ask you to construct and interpret a confidence interval:<br>
- <strong>State</strong>: State the parameter you want to estimate and the confidence level.<br>
- <strong>Plan</strong>: Identify the appropriate inference method and check the conditions.<br>
- <strong>Do</strong>: If the conditions are met, perform calculations.<br>
- <strong>Conclude</strong>: Interpret your interval in the context of the problem.</p>
<p>The size of the margin of error is determined by several factors, including the confidence level <span class="math inline">\(C\)</span> and the sample size <span class="math inline">\(n\)</span>. Increasing the sample size <span class="math inline">\(n\)</span> makes the standard error of our statistic smaller, decreasing the margin of error. Increasing the confidence level <span class="math inline">\(C\)</span> makes the margin of error larger, to ensure that the capture rate of the interval increases to <span class="math inline">\(C\%\)</span>. Remember that the margin of error only accounts for sampling variability–it does not account for any bias in the data collection process.</p>
<p>Finally, an important part of planning a study is determining the size of the sample to be selected. The necessary sample size is based on the confidence level, the proportion of successes, and the desired margin of error. To calculate the minimum sample size, solve the following inequality for <span class="math inline">\(n\)</span>, where <span class="math inline">\(\hat{p}\)</span> <span class="math inline">\(\hat{p}\)</span> is a guessed value for the sample proportion: <span class="math display">\[z^\ast\sqrt{\frac{\hat{p}(1-\hat{p})}{n}} \le ME\]</span> If you do not have an approximate value of <span class="math inline">\(\hat{p}\)</span> from a previous study or a pilot study, use <span class="math inline">\(\hat{p}=0.5\)</span> to determine the sample size that is guaranteed to yield a value less than or equal to the desired margin of error.</p>
</section>
<section id="section-6c-significance-tests-the-basics" class="level4">
<h4 class="anchored" data-anchor-id="section-6c-significance-tests-the-basics">Section 6C: Significance Tests: The Basics</h4>
<p>In this section, you learned the basic ideas of <strong>significance testing</strong>. Start by stating the hypotheses that you want to test. The <strong>null hypothesis</strong> (<span class="math inline">\(H_0\)</span>) is typically a statement of “no difference” and the <strong>alternative hypothesis</strong> (<span class="math inline">\(H_a\)</span>) describes what we expect is true. Remember that hypotheses are always about population parameters, not sample statistics.</p>
<p>When sample data provide evidence for the alternative hypothesis, there are two possible explanations: (<span class="math inline">\(1\)</span>) the null hypothesis is true, and data supporting the alternative hypothesis occurred just by chance, or (<span class="math inline">\(2\)</span>) the alternative hypothesis is true, and the data are consistent with an alternative value of the parameter. In a significance test, we evaluate Explanation 1 by assuming the null hypothesis is true and calculating the probability of getting evidence for the alternative hypothesis as strong as or stronger than the observed data. This probability is called a <strong><span class="math inline">\(P\)</span>-value</strong>.</p>
<p>To determine if the <span class="math inline">\(P\)</span>-value is small enough to reject <span class="math inline">\(H_0\)</span>, compare it to a predetermined <strong>significance level</strong> such as <span class="math inline">\(\alpha=0.05\)</span>. If the <span class="math inline">\(P\)</span>-value <span class="math inline">\(\le\alpha\)</span>, reject <span class="math inline">\(H_0\)</span>–there is convincing evidence that the alternative hypothesis is true.</p>
</section>
<section id="section-6d-significance-tests-for-a-population-proportion" class="level4">
<h4 class="anchored" data-anchor-id="section-6d-significance-tests-for-a-population-proportion">Section 6D: Significance Tests for a Population Proportion</h4>
<p>In this section, you learned the details of performing a significance test about a population proportion <span class="math inline">\(p\)</span>. After stating hypotheses and before doing calculations, check the conditions to verify that the observations in the sample are independent and that the observations in the sample are independent and that the sampling distribution of <span class="math inline">\(\hat{p}\)</span> is approximately normal. The Random condition requires that the sample be randomly selected from the population. The <span class="math inline">\(10\%\)</span> condition requires that the sample size be less than <span class="math inline">\(10\%\)</span> of the population size when sampling without replacement from the population. Finally, the Large Counts condition says that both <span class="math inline">\(np_0\)</span> and <span class="math inline">\(n(1-p_0)\)</span> must be at least <span class="math inline">\(10\)</span>, where <span class="math inline">\(p_0\)</span> is the value of <span class="math inline">\(p\)</span> in the null hypothesis.</p>
<p>The <strong>standardized test statistic</strong> measures how far the observed value of <span class="math inline">\(\hat{p}\)</span> is from the null hypothesis value, in standard error units. <span class="math display">\[\text{standardized test statistic} = \frac{\text{statistic} - \text{parameter}}{\text{standard error of statistic}}\]</span> <span class="math display">\[z = \frac{\hat{p}-p_0}{\sqrt{\frac{p_0(1-p_0)}{n}}}\]</span> Find the <span class="math inline">\(P\)</span>-value by calculating the probability of getting a <span class="math inline">\(z\)</span> statistic this large or larger in the direction specified by the alternative hypothesis <span class="math inline">\(H_a\)</span> in the standard normal distribution. If you are performing a <strong>two-sided test</strong>, make sure to find the area in both tails of the standard normal distribution.</p>
<p>Whenever you are asked if there is convincing evidence for a claim about a population parameter, you are expected to respond using the familiar four-step process:<br>
<strong>State</strong>: State the hypotheses, parameter(s), and significance level.<br>
<strong>Plan</strong>: Identify the appropriate inference method and check the conditions.<br>
<strong>Do</strong>: If the conditions are met, perform calculations:<br>
* Calculate the test statistic.<br>
* Find the <span class="math inline">\(P\)</span>-value.</p>
<p><strong>Conclude</strong>: Make a conclusion about the hypotheses in the context of the problem.</p>
<p>You can also use a confidence interval to make a conclusion for a two-sided test. If the null parameter value is one of the plausible values in the interval, there isn’t convincing evidence that the alternative hypothesis is true. However, if the interval contains only values consistent with the alternative hypothesis, there is convincing evidence that the alternative hypothesis is true. Besides helping you draw a conclusion, the interval tells you which alternative parameter values are plausible.</p>
<p>Because conclusions are based on sample data, there is a possibility that the conclusion to a significance test will be incorrect. You can make two types of errors: A <strong>Type I error</strong> occurs if you find convincing evidence for the alternative hypothesis when, in reality, the null hypothesis is true. A <strong>Type II error</strong> occurs when you don’t find convincing evidence that the alternative hypothesis is true. The probability of making a Type I error is equal to the significance level (<span class="math inline">\(\alpha\)</span>) of the test. Decreasing the probability of a Type I error increases the probability of a Type II error, and increasing the probability of a Type I error decreases the probability of a Type II error.</p>
<p>The probability that you avoid making a Type II error when an alternative value of the parameter is true is called the <strong>power</strong> of the test. Power is good–if the alternative hypothesis is true, you want to maximize the probability of finding convincing evidence that it is true. We can increase the power of a significance test by increasing the sample size, by increasing the significance level, and by reducing the standard error with wise data collection methods. The power of a test will also be greater when the alternative value of the parameter is farther away from the null hypothesis value.</p>
</section>
</section>
<section id="inference-for-a-population-proportion" class="level3">
<h3 class="anchored" data-anchor-id="inference-for-a-population-proportion">Inference for a Population Proportion</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 28%">
<col style="width: 35%">
<col style="width: 35%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Name (TI-83/84)</strong></td>
<td style="text-align: left;">One-sample <span class="math inline">\(z\)</span> interval for <span class="math inline">\(p\)</span> (1-PropZInt)</td>
<td style="text-align: left;">One-sample <span class="math inline">\(z\)</span> test for <span class="math inline">\(p\)</span> (1-PropZTest)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Null Hypothesis</strong></td>
<td style="text-align: left;"><em>Not applicable.</em></td>
<td style="text-align: left;"><span class="math inline">\(H_0:p=p_0\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Conditions</strong></td>
<td style="text-align: left;"><strong>Random</strong>: The data come from a random sample for the population of interest. <br><br><strong><span class="math inline">\(10\%\)</span></strong>: When sampling without replacement, <span class="math inline">\(n \lt 0.10N\)</span>. <br><br><strong>Large Counts</strong>: Both <span class="math inline">\(n\hat{p}\)</span> and <span class="math inline">\(n(1-\hat{p})\)</span> are at least <span class="math inline">\(10\)</span>.<br><br> That is, the number of successes and the number of failures in the sample are both at least 10.</td>
<td style="text-align: left;"><strong>Random</strong>: The data come from a random sample for the population of interest. <br><br><strong><span class="math inline">\(10\%\)</span></strong>: When sampling without replacement, <span class="math inline">\(n \lt 0.10N\)</span>. <br><br><strong>Large Counts</strong>: Both <span class="math inline">\(np_0\)</span> and <span class="math inline">\(n(1-p_0)\)</span> are at least <span class="math inline">\(10\)</span><br><br> where <span class="math inline">\(p_0\)</span> is the proportion specified by the null hypothesis.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Formula</strong></td>
<td style="text-align: left;"><span class="math display">\[\hat{p} \pm z^\ast\sqrt{\frac{\hat{p}(1-\hat{p})}{n}}\]</span><br> Critical value <span class="math inline">\(z^\ast\)</span> from the standard normal distribution</td>
<td style="text-align: left;"><span class="math display">\[z = \frac{\hat{p}-p_0}{\sqrt{\frac{p_0(1-p_0)}{n}}}\]</span><br> <span class="math inline">\(P\)</span>-value from the standard normal distribution</td>
</tr>
</tbody>
</table>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<footer>© 2025 Thomas Abraham</footer>
</body></html>